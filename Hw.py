# Задача 1.

# На заводе «Кофейный» открывается новое кафе. Изначально есть некоторое количество
# кофейных зерен, молока и взбитых сливок.

# Надо написать функцию choose_coffee(preference1, preference2,..., preferenceN), которая
# возвращает напиток, который можно приготовить из имеющихся продуктов (ingredients). На
# вход функция принимает заранее неизвестное количество предпочтений посетителя. Все
# напитки перечислены в порядке убывания предпочтений и гарантированно не повторяются.
# Бариста готовит наиболее предпочитаемый напиток из доступных.

# Для Эспрессо требуется: 1 порция кофейных зерен.
# Для Капучино требуется: 1 порция кофейных зерен и 3 порции молока.
# Для Маккиато требуется: 2 порции кофейных зерен и 1 порция молока.
# Для Кофе по-венски требуется: 1 порция кофейных зерен и 2 порции взбитых сливок.
# Для Латте Маккиато требуется: 1 порция кофейных зерен, 2 порции молока и 1 порция взбитых
# сливок.
# Для Кон Панна требуется: 1 порция кофейных зерен и 1 порция взбитых сливок.

# При приготовлении напитка ингредиенты расходуются.
# Если недостаточно ингредиентов, то вернуть сообщение: «К сожалению, не можем предложить
# Вам напиток».


def choose_coffee(*process):
    global ingredients
    recept = {'Эспрессо': {'cof': 1, 'milk': 0, 'sl': 0},
                 'Капучино': {'cof': 1, 'milk': 3, 'sl': 0},
                 'Кофе по-венски': {'cof': 1, 'milk': 0, 'sl': 2},
                 'Латте Маккиато': {'cof': 1, 'milk': 2, 'sl': 1},
                 'Кон Панна': {'cof': 1, 'milk': 0, 'sl': 1},
                 'Маккиато': {'cof': 2, 'milk': 1, 'sl': 0}}
    cof = ingredients[0]
    milk = ingredients[1]
    sl = ingredients[2]
    for i in process:
        one = cof - recept[i]['cof']
        two = milk - recept[i]['milk']
        three = sl - recept[i]['sl']
        if one >= 0 and two >= 0 and three >= 0:
            ingredients[0] -= recept[i]['cof']
            ingredients[1] -= recept[i]['milk']
            ingredients[2] -= recept[i]['sl']
            return i
    return 'К сожалению, мы не можем предложить Вам напиток'


# Задача 2.

# Напишите функцию encrypt_caesar(msg, shift), которая кодирует сообщение шифром
# Цезаря и возвращает его. Шифр Цезаря заменяет каждую букву в тексте на букву, которая
# отстоит в алфавите на некоторое фиксированное число позиций.

# В функцию передается сообщение и сдвиг алфавита. Если сдвиг не указан, то пусть ваша
# функция кодирует сдвиг алфавита на 3 позиции:

# А→Г,А→Г,
# Б→Д,Б→Д,
# В→Е,В→Е,
# ……
# Э→А,Э→А,
# Ю→Б,Ю→Б,
# Я→ВЯ→В

# Все символы, кроме русских букв должны остаться неизменными. Маленькие буквы должны
# превращаться в маленькие, большие — в большие.

# Напишите также функцию декодирования decrypt_caesar(msg, shift), также
# использующую сдвиг по умолчанию. При написании функции декодирования используйте
# вашу функцию кодирования.


llst = ['а','б','в','г','д','е','ж','з','и','й','к','л','м','н','о',
'п','р','с','т','у','ф','х','ц','ч','ш','щ','ъ','ы','ь','э','ю','я']

def charSplit(str):
    return [char for char in str]


chars = charSplit(llst)
result = []
finalResult = ""
charsInd = 0
strIndex = 0
found = False
s = input("Введите текст: ")
go = int(input("Введите шаг шифра: "))

while found == False:
    if len(result) == len(s):
            found = True
       
    elif s[strIndex] == " ":
            result.append(" ")
            strIndex += 1
        
    elif charSplit(s)[strIndex].lower() == chars[charsInd]:
            result.append(chars[charsInd - go])
            strIndex += 1

    else:
        if len(chars) - 1 == charsInd:
                charsInd = 0
        else:
                charsInd += 1

for l in result:
        finalResult += l

print(finalResult)